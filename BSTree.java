import java.util.Scanner;import java.util.ArrayList;import java.lang.Math;// Java program who demonstrate a binary search treepublic class BSTree implements BSTOper {// Root of BST, starting NodeNode root;    // metoder fra BSTOper    // brukes til rød-svarte trær (tilleggsoppgave)    private byte BLACK = 1;    private byte RED = 2;// ConstructorBSTree(){    this.root = null;}// The public method that starts the recursion from the root node.public void add(int value) {    if (root == null) {        root = new Node(value);    } else {        add(root, value);    }}// Helping method for adding node in the tree.    private void add(Node node, int value) {        if (node.value > value) {            if (node.left == null) {                node.left = new Node(value);                return;            } else {                add(node.left, value);            }        } else if (node.value < value) {            if (node.right == null) {                node.right = new Node(value);                return;            } else {                add(node.right, value);            }        }    }    public boolean remove(int value) {        //Start at the top of the tree        Node focusNode = root;        Node parent = root;        //When searching for a Node this will tell us whether to search to the right or left        boolean isItAleftChild = true;        //while we havent found the Node, we keep looking        while (focusNode.value != value){            parent = focusNode;            if (value < focusNode.value){                isItAleftChild = true;                //shift the focus node to the left child                focusNode = focusNode.left;            }else{                //Greater than the focusNode, then go to the right                isItAleftChild = false;                //shift the focus to right child                focusNode = focusNode.right;            }            //the node was not found            if (focusNode == null)                return false;        }        // If Node doesn't have children delete it        if (focusNode.left == null && focusNode.right == null) {            // If root delete it            if (focusNode == root)                root = null;                // If it was marked as a left child                // of the parent delete it in its parent            else if (isItAleftChild)                parent.left = null;                // Vice versa for the right child            else                parent.right = null;            }            // If no right child            else if (focusNode.right == null) {                if (focusNode == root)                    root = focusNode.left;                    // If focus Node was on the left of parent                    // move the focus Nodes left child up to the                    // parent node                else if (isItAleftChild)                    parent.left = focusNode.left;                    // Vice versa for the right child                else                    parent.right = focusNode.left;            }            // If no left child            else if (focusNode.left == null) {                if (focusNode == root)                    root = focusNode.right;                    // If focus Node was on the left of parent                    // move the focus Nodes right child up to the                    // parent node                else if (isItAleftChild)                    parent.left = focusNode.right;                    // Vice versa for the left child                else                    parent.right = focusNode.right;            }            else {                Node replacement = getReplacementNode(focusNode);                // If the focusNode is root replace root                // with the replacement                if (focusNode == root)                    root = replacement;                    // If the deleted node was a left child                    // make the replacement the left child                else if (isItAleftChild)                    parent.left = replacement;                    // Vice versa if it was a right child                else                    parent.right = replacement;                replacement.left = focusNode.left;            }            return true;    }        public Node getReplacementNode(Node replacedNode) {            Node replacementParent = replacedNode;            Node replacement = replacedNode;            Node focusNode = replacedNode.right;            // While there are no more left children            while (focusNode != null) {                replacementParent = replacement;                replacement = focusNode;                focusNode = focusNode.left;            }            // If the replacement isn't the right child            // move the replacement into the parents            // leftChild slot and move the replaced nodes            // right child into the replacements rightChild            if (replacement != replacedNode.right) {                replacementParent.left = replacement.right;                replacement.right = replacedNode.right;            }            return replacement;        }// Given a binary tree, print its nodes in level order using av array for implementing a queue.    public int size() {        return size(root);    }    //Computes the number of nodes in the tree    int size(Node node){    if (node == null)        return 0;        else            return (size(node.left) + 1 + size(node.right));    }// return true if this BST contains the give integer valuepublic boolean existsInTree(int value){    return existsInTree(root, value);}    // Recursive helper to search the given subtree for the given value.    private boolean existsInTree(Node root, int value) {        if (root == null) {            return false;        } else if (root.value == value) {            // this node is the value we're looking for            return true;        } else if (root.value > value) {            // this node is too large; go left            return existsInTree(root.left, value);        } else {            // root.data < value            // this node is too small; go right            return existsInTree(root.right, value);        }    }    public int findNearestSmallerThan(int value) {        if (root == null) {            return -1;        } else {            return findNearestSmallerThan(root, value, 0);        }    }    private int findNearestSmallerThan(Node root, int value, int lowestvalue) {        if (root.left != null) {            lowestvalue = findNearestSmallerThan(root.left, value, lowestvalue);        }        if (root.value >= lowestvalue && root.value < value) {            lowestvalue = root.value;        }        if (root.right != null) {            lowestvalue = findNearestSmallerThan(root.right, value, lowestvalue);        }        return lowestvalue;    }    public void addAll(int[] integers) {        if (root == null) {            return;        } else {            for (int i = 0; i < integers.length; i++) {                add(integers[i]);            }        }    }    /* A function that constructs Balanced Binary Search Tree    from a sorted array */    public int[] sortedArray() {       ArrayList<Node> list = new ArrayList<>();       traverseInOrder(root,list);       int[] tallarray = new int[list.size()];       for (int i = 0;  i < tallarray.length; i++)           tallarray[i] = list.get(i).value;       return tallarray;    }    public int[] findInRange(int low, int high) {        if (root == null) {            return null;        } else {            return findInRange(root, new int[0], low, high);        }    }    //Hjelpemetode    //Returns the count of nodes in BST in range [low, high]    //// Finne alle verdier mellom low og high i treet ditt    private int[] findInRange(Node node, int[] list, int low, int high) {        if (node.left != null) {            list = findInRange(node.left, list, low, high);        }        if (node.value >= low && node.value <= high) {            int[] newlist = new int[list.length + 1];            int index = 0;            for (int i : list) {                newlist[index++] = i;            }            newlist[list.length] = node.value;            list = newlist;        }        if (node.right != null) {            list = findInRange(node.right, list, low, high);        }        return list;    }    // konstruktører til BSTree    private Node findParent(Node node) {        if (root == null) {            return null;        } else {            return findParent(root, node);        }    }    // Returns the parent of a given value    private Node findParent(Node start, Node node) {        if (start.value > node.value) {            if (start.left == null) {                return null;            } else if (start.left == node) {                return start;            }            return findParent(start.left, node);        } else {            if (start.right == null) {                return null;            } else if (start.right == node) {                return start;            }            return findParent(start.right, node);        }    }    private Node findGrandparent(Node root) {        if (root.parent.parent != null){            return root.parent.parent;        }        else {            return null;        }    }    private Node findGrandParent(Node node) {        return findParent(findParent(node));    }  //Traverse the tre inorder ( left, then root, then right) A, B, C    public void traverseInOrder(Node root, ArrayList<Node> list){    if(root == null){       return;    }        traverseInOrder(root.left, list);        System.out.printf("%s ", root.value);        list.add(root);        traverseInOrder(root.right, list);    }     /* Let us create following BST              B           /     \          A       C                            */    //Traverse the tree in preOrder (root, then left, then right) B, A , C    public static void preOrder(Node root){    if (root == null){        return;    }    System.out.printf("%s ", root.value);    preOrder(root.left);    preOrder(root.right);    }    // Traverse the tree in postOrder (left, then right, then root) A, C , B    public static void postOrder(Node root){    if (root == null){        return;    }    postOrder(root.left);    postOrder(root.right);    System.out.printf("%s ", root.value);    }// Class containing left and right child of current node and key valueclass Node {    int value;    Node left, right, parent;    public Node(int value){        this.value = value;        left = right = null;    }    public String toString(){        return "The tree has node "+ value;    }}}